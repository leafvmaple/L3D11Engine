/*=============================================================================
    NodeInterface.h5: implement of the shader code node interface.
=============================================================================*/
//defined by c++

#ifndef __NODE_INTERFACE_H5_
#define __NODE_INTERFACE_H5_

#ifdef USER_TEXCOORD1
	#undef NUM_USER_TEXCOORDS
    #define NUM_USER_TEXCOORDS 1
#endif

#ifdef USER_TEXCOORD2
	#undef NUM_USER_TEXCOORDS
	#define NUM_USER_TEXCOORDS 2
#endif

#ifdef USER_TEXCOORD3
		#undef NUM_USER_TEXCOORDS
	#define NUM_USER_TEXCOORDS 3
#endif

#define PARAMTER_TEXCOORD(Parameters,Index)     Parameters.TexCoords[min( NUM_USER_TEXCOORDS - 1, Index)]
#define PARAMTER_TEXCOORD_UVW(Parameters,Index)     Parameters.TexCoordsUVW[min( NUM_USER_TEXCOORDS - 1, Index)]

#ifdef TERRAIN
	#undef NUM_USER_TEXCOORDS
    #define NUM_USER_TEXCOORDS 1
#else
	#ifndef NUM_USER_TEXCOORDS
		#define NUM_USER_TEXCOORDS 1
	#endif
#endif

#ifdef SPEEDTREE
	#undef NUM_USER_TEXCOORDS
	#define NUM_USER_TEXCOORDS 7
#endif

#ifdef WATER
	#undef NUM_USER_TEXCOORDS
	#define NUM_USER_TEXCOORDS 1
	#undef  NUM_USER_TEXCOORDS_UVW
	#define NUM_USER_TEXCOORDS_UVW 1
#endif

#ifndef NORMALMAP
	#define NORMALMAP 1
#endif

struct MaterialTessllationParameters
{
#if NUM_USER_TEXCOORDS
    float2 TexCoords[NUM_USER_TEXCOORDS];
#endif
#if NUM_USER_TEXCOORDS_UVW
	float3 TexCoordsUVW[NUM_USER_TEXCOORDS_UVW];
#endif

    float3 WorldPosition; 
    float3 VertexPosition;
    float3 VertexNormal;
    float4 VertexTangent;
    float4 VertexColor;
    float4 ModelColor;
    float3 ModelColorOffset;
    float4 ParticleVertexColor;
    float4 WeightHeightMapTexcoord;

	float4x4 MatrixWorld;
	float4x4 MatrixWorldInverse;
	float4x4 MatrixWorldInverseTranspose;

	float2  SplineUV;
	float3  SplineDir;
	float   SplineT;
};

struct MaterialVertexParameters
{
    float3 VertexPosition;
    float3 VertexNormal;
    float4 VertexColor;
    float4 VertexTangent;

#if NUM_USER_TEXCOORDS
    float2 TexCoords[NUM_USER_TEXCOORDS];
#endif
#if NUM_USER_TEXCOORDS_UVW
	float3 TexCoordsUVW[NUM_USER_TEXCOORDS_UVW];
#endif
   	float4 ModelColor;
    float3 ModelColorOffset;
	float4 ParticleVertexColor;

#if defined(INSTANCE_INPUT)
    float3x3 MatrixInstanceLocal;
    float3 VertexWorldOffset;
	float fAlphaTransition;
#elif  defined(VERTEX_WORLDOFFSET)
    float3 VertexWorldOffset;
#endif
	float3 WorldPosition;
	float4 ActorParams;
	float4 FoliageParams;

	float fStartChangeTime;

	float3 WorldMotion;
	float4 LastWorldPosition;
	float  MotionPrecision; 
	float  IsMoving;

	float4x4 MatrixWorld;
	float4x4 MatrixWorldInverse;
	float4x4 MatrixWorldInverseTranspose;

#ifndef TESSELLATION_VS
	float2  SplineUV;
	float3  SplineDir;
	float   SplineT;
#endif
};

struct MaterialVertexOutputs
{
    float4 VertexColor;
    float4 WorldPosition;
    float3 WorldNormal;
    float4 ScreenPosition;
    float4 VertexPosition;
    float3 VertexNormal;
    float4 VertexTangent;

#if NUM_USER_TEXCOORDS
    float2 TexCoords[NUM_USER_TEXCOORDS];
#endif
#if NUM_USER_TEXCOORDS_UVW
	float3 TexCoordsUVW[NUM_USER_TEXCOORDS_UVW];
#endif
    float3 WorldTangent;
    float3 WorldBinormal;
    float  ClipDistance;
    float  FogFactor;
	float  fAlphaTransition;
    float4 ModelColor;
    float3 ModelColorOffset;
	float4 ParticleVertexColor;
	float  fStartChangeTime;
	float2 ScreenMotion;
	float  MotionPrecision;
	float  IsMoving;
	bool   IsFrontFace;
    float4 WeightHeightMapTexcoord;

	float4x4 MatrixWorld;
	float4x4 MatrixWorldInverse;

	float2  SplineUV;
	float3  SplineDir;
	float   SplineT;
};

struct MaterialGeometryParameters
{
#if NUM_USER_TEXCOORDS
    float2 TexCoords[NUM_USER_TEXCOORDS];
#endif
#if NUM_USER_TEXCOORDS_UVW
	float3 TexCoordsUVW[NUM_USER_TEXCOORDS_UVW];
#endif
    float3 WorldNormal;
    float3 WorldPosition;
    float3 VertexPosition;
    float3 VertexNormal;
    float4 ScreenPosition;
	float4 OutPosition;
    float4 VertexColor;
    float3 Tangent;
    float3 Binormal;
    float4 ModelColor;

	float4x4 MatrixWorld;
	float4x4 MatrixWorldInverse;
	float4x4 MatrixWorldInverseTranspose;
};

struct MaterialPixelParameters
{
#if NUM_USER_TEXCOORDS
    float2  TexCoords[NUM_USER_TEXCOORDS];
#endif
#if NUM_USER_TEXCOORDS_UVW
	float3 TexCoordsUVW[NUM_USER_TEXCOORDS_UVW];
#endif
    float3  WorldNormal;
    float3  WorldPosition; 
    float3  VertexPosition;
    float3  VertexNormal;
    float4  ScreenPosition;
	float4	OutPosition;
    float4  VertexColor;
    float3  Tangent;
    float3  Binormal;
    float   FogFactor;
    float4  ModelColor;
    float3  ModelColorOffset;
	float4  ParticleVertexColor;
	float4  WeightHeightMapTexcoord;

	float4x4 MatrixWorld;
	float4x4 MatrixWorldInverse;
	float4x4 MatrixWorldInverseTranspose;
	
	float2  ScreenMotion;
	float   MotionPrecision;
	float   IsMoving;
	float   IsFrontFace;

	//layerinfo£¬used in blend function only
	float	BaseLayerHeight;
	float	CurrentLayerHeight;
	float	PreviousLayerHeight;

    float   CurrentLayerMask;
    float   CurrentLayerInfo;

	float2  SplineUV;
	float3  SplineDir;
	float   SplineT;
};

struct ParamsMainVertexNode
{
    float3  WorldPositionOffset;
};

struct ParamsMainHullNode
{
    float   TessellationMultiplier;
};

struct ParamsMainDomainNode
{
    float3  WorldDisplacement;
    float   MaterialHeight;
};

struct ParamsMainGeometryNode
{
    // Fur
    float FurMask;		//not working yet
    float FurGravityIntensity;

    // Shell
    float FurShellAmount; //= 16;
    float FurShellLength; //= 0.3;
    float FurShellOpacity;

    //Fin
    float FurFinLength;		//not working yet
};

struct ParamsMainPixelNode
{
    float3  Albedo;
    float3  SpecularColor;
    float   Reflectivity;
    float   Fresnel;
    float   Roughness;
    float3  Normal;					//on local space
	float3	TangentNormal;			//on tangent space
    float3  Emissive;
    float   Opacity;
	float   PixelDepthOffset;
    float4  CustomLighting;
    float3  Ambient;
    float   SpecularPower;
	float	Anisotropic;
    float   AnisoAngle;
	float	AO;
	float	SSSWidth;
    float   SSSTranslucency;
    float3	SSSStrength;
	float3	SSSFallOff;
	int		SSSProfileID;
    float3  SubsurfaceColor;
    float   SubsurfaceProportion;
    float   SubsurfaceWrap;
	float3  TransmitColor;
	float3  InnerNormal;
	float3  TranslucencyColor;
	float	Scatter;
	float3	Tangent;
	float	Cloth;
	float	MaterialHeight;
	float4  CustomData;
};

struct NearRangeData
{
	float2 Dir;
	float2 Gradient;
	float2 WaveVelocityFactor;
	float2 Curvature;
	float2 Distance;
};

struct NearWaterData
{
	float3 Displacement;
};

struct NearTerrainData
{
	float Height;
};

Texture2D g_texLayerMask;
Texture2D g_texGeometryNormal;
Texture2D g_texGeometryInfo;


// Represent : eyes
float3 GetCameraPosition() 
{ 
    return g_Com.Camera.EyePosition;
}

float GetCameraNear()
{
	return g_Com.Camera.CameraFactor.x;
}

float GetCameraFar()
{
	return g_Com.Camera.CameraFactor.y;
}

float GetCameraFov()//if Perspective |FovAngleY| else |VisibleWidth|
{
	return g_Com.Camera.CameraFactorEx.x;
}

float GetCameraAspect()//if Perspective |AspectRatio| else |VisibleHeight|
{
	return g_Com.Camera.CameraFactorEx.y;
}
float3 GetCameraLook()
{
	return normalize(g_Com.Camera.CameraFront);
}

// Represent : -sunLight.m_dir
float3 GetSunLightDir()
{
    return g_Com.SunLightParam.Direction;
}

// Represent : vConverRect
float4 GetConverRect()
{
    return float4(
        g_Com.ConvertMap.fXBegin, g_Com.ConvertMap.fZBegin, 
        g_Com.ConvertMap.fXWidth, g_Com.ConvertMap.fZWidth
    );
}

float GetTime()
{
    return g_Com.TimeSEC;
}

float GetRelativeYearTime()
{
    return g_Com.RelativeYearTime;
}

#ifndef CUSTOM_IS_USECOVERMAP
float IsUseCovermap()
{
    return g_Com.Switch.bEnableConvertMap;
}
#endif

#endif