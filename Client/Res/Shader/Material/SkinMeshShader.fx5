/*=============================================================================
    SkinMeshShader.fx5.
=============================================================================*/
#define SHADOWMAP
#define COVERMAP
#include "CommonParam.h"

//This must match the KG3D_MTLSYS_SKINMESH_SHARED_CB in KG3D_MaterialConfig.h
static const int MAX_NUM_BONE_PER_SET = 158;
struct KG3D_MTLSYS_SKINMESH_SHARED_CB 
{
    row_major float4x4 MatrixWorld;
    row_major float4x4 MatrixWorldInverse;
    row_major float4x4 MatrixWorldInverseTranspose;
	row_major float4x4 LastMatrixWorld;
    float4 WorldDisplacement;
	float4 WorldRotationEularAngle;
	float4 WorldRotationQuaternion;
	float4 WorldScaling;
};

struct MaterialVertexParameters
{
    float3 VertexPosition;
    float3 VertexNormal;
    float4 VertexColor;
    float4 VertexTangent;

#if NUM_USER_TEXCOORDS
    float2 TexCoords[NUM_USER_TEXCOORDS];
#endif
#if NUM_USER_TEXCOORDS_UVW
	float3 TexCoordsUVW[NUM_USER_TEXCOORDS_UVW];
#endif
   	float4 ModelColor;
    float3 ModelColorOffset;
	float4 ParticleVertexColor;

#if defined(INSTANCE_INPUT)
    float3x3 MatrixInstanceLocal;
    float3 VertexWorldOffset;
	float fAlphaTransition;
#elif  defined(VERTEX_WORLDOFFSET)
    float3 VertexWorldOffset;
#endif
	float3 WorldPosition;
	float4 ActorParams;
	float4 FoliageParams;

	float fStartChangeTime;

	float3 WorldMotion;
	float4 LastWorldPosition;
	float  MotionPrecision; 
	float  IsMoving;

	float4x4 MatrixWorld;
	float4x4 MatrixWorldInverse;
	float4x4 MatrixWorldInverseTranspose;

#ifndef TESSELLATION_VS
	float2  SplineUV;
	float3  SplineDir;
	float   SplineT;
#endif
};

cbuffer ModelSharedParam : register(b2)
{
    row_major float4x4 g_CustomMatrixBones[MAX_NUM_BONE_PER_SET];// this must be first for RTX Compute vertex.

    KG3D_MTLSYS_SKINMESH_SHARED_CB g_ModelParams;
    
    POINT_LIGHT_PARAM g_PointLightParam;
    DIRECTIONAL_LIGHT_PARAM g_DirectionalLightParam;
    SPOT_LIGHT_PARAM g_SpotLightParam;

	DETAIL_TEXTURE_PARAM_OLD DetailTextureParam;

    float4  GlowBlendColor = float4(1.0f, 1.0f, 1.0f, 1.0f);
    bool    EnableGlowBlend = false;
    float   GlowBlendFactor = 0;
    bool    EnableDetail = false;
    bool    EnableSpecialLight = false;
    bool    IsDX9Resource = false;
    bool    IsCovermapTransform = true;
	uint    Flags = 0x0;
	bool	IsParsyMesh	= false;

    int     BlendShapeNum = 0;
    int     BlendShapePitch = 0;

    int2    Paddings0;
};

cbuffer SubsetConstParam : register (b3)
{
    float4  ModelColor = float4(1.0f, 1.0f, 1.0f, 1.0f);
    float3  ModelColorOffset = float3(0.0f, 0.0f, 0.0f);
    bool    EnableAlphaTest = false;
    float   AlphaReference = 0.0f;
    float   AlphaReference2 = 0.0f;
    bool    EnableTwoSide = false;
    int     Paddings1;
};

#define CUSTOM_IS_USECOVERMAP
bool IsUseCovermap() 
{
    return g_Com.Switch.bEnableConvertMap && IsCovermapTransform;
}

#include "NodeInterface.h5"
#include "MaterialTemplate.fx5"
#include "UserShader.fx5"

#define POINTLIGHT
#include "Light.h"



struct VertexInput
{
    float4 Position : POSITION0;
    float3 Normal   : NORMAL0;
    float4 Color    : COLOR0;

#if NUM_USER_TEXCOORDS
    float2 TexCoords[NUM_USER_TEXCOORDS] : TEXCOORD0;
#endif

    float4 Weights  : BONEWEIGHTS0;
    uint4  Indices  : BONEINDICES0;
    float4 Tangent  : TANGENT0;
};

struct VertexOutput
{
    float4 OutPosition          : SV_Position;
    float4 Color                : COLOR0;
	float4 ParticleVertexColor  : COLOR1;
	float4 ScreenMotion		    : COLOR2;
	float4 MatrixWorld0		: COLOR3;
	float4 MatrixWorld1		: COLOR4;
	float4 MatrixWorld2		: COLOR5;
	float4 MatrixWorld3		: COLOR6;
	float4 MatrixWorldInverse0 : COLOR7;
	float4 MatrixWorldInverse1 : COLOR8;
	float4 MatrixWorldInverse2 : COLOR9;
	float4 MatrixWorldInverse3 : COLOR10; 
    float4 WorldPosition        : TEXCOORD0;
    float4 Normal_Fog           : TEXCOORD1;
    float4 ScreenPosition       : TEXCOORD2;
    float4 VertexPosition       : TEXCOORD3;
    float3 VertexNormal         : TEXCOORD4;

#if NUM_USER_TEXCOORDS
    float2 TexCoords[NUM_USER_TEXCOORDS] : TEXCOORD5;
#endif

    float3 Tangent              : TANGENT0;
    float3 Binormal             : BINORMAL0;

    float  ClipDistance         : SV_ClipDistance0;

#ifdef FUR
    float Opacity : OPACITY0;
    float2 FinOpacity : OPACITY1;
    bool Needed : NEED;
#endif
};

struct PixelSystemInput
{
    bool IsFrontFace		    : SV_IsFrontFace;
};

struct ZOutput
{
    float4    ScreenPos : SV_Position;
    float2    Texcoord  : TEXCOORD0;
    float2    RawPos    : TEXCOORD1;
};

MaterialVertexParameters GetMaterialVertexParameters(VertexInput Input)
{
    MaterialVertexParameters Params = (MaterialVertexParameters)0;
    float4 position;
    float3 normal;
    float3 tangent;

    float3x3 InvTransposeCustomMatrixBonesX = GetMatrixForNormal(g_CustomMatrixBones[Input.Indices.x]);
    position = mul(Input.Position,       g_CustomMatrixBones[Input.Indices.x])                  * Input.Weights.x;
    normal   = mul(Input.Normal,         InvTransposeCustomMatrixBonesX)					    * Input.Weights.x;
    tangent  = mul(Input.Tangent.xyz,    InvTransposeCustomMatrixBonesX)					    * Input.Weights.x;

    if (Input.Indices.y != 255)                                              
    {
        float3x3 InvTransposeCustomMatrixBonesY = GetMatrixForNormal(g_CustomMatrixBones[Input.Indices.y]);                                                                      
        position    += mul(Input.Position,      g_CustomMatrixBones[Input.Indices.y])           * Input.Weights.y;
        normal      += mul(Input.Normal,        InvTransposeCustomMatrixBonesY)					* Input.Weights.y;
        tangent     += mul(Input.Tangent.xyz,   InvTransposeCustomMatrixBonesY)					* Input.Weights.y;
    }                                                                      
    if (Input.Indices.z != 255)                                              
    {
        float3x3 InvTransposeCustomMatrixBonesZ = GetMatrixForNormal(g_CustomMatrixBones[Input.Indices.z]);                                                                      
        position    += mul(Input.Position,      g_CustomMatrixBones[Input.Indices.z])           * Input.Weights.z;
        normal      += mul(Input.Normal,        InvTransposeCustomMatrixBonesZ)					* Input.Weights.z;
        tangent     += mul(Input.Tangent.xyz,   InvTransposeCustomMatrixBonesZ)					* Input.Weights.z;
    }                                              

    if (Input.Indices.w != 255)                                              
    {
        float3x3 InvTransposeCustomMatrixBonesW = GetMatrixForNormal(g_CustomMatrixBones[Input.Indices.w]);                                                                      
        position    += mul(Input.Position,      g_CustomMatrixBones[Input.Indices.w])           * Input.Weights.w;
        normal      += mul(Input.Normal,        InvTransposeCustomMatrixBonesW)					* Input.Weights.w;
        tangent     += mul(Input.Tangent.xyz,   InvTransposeCustomMatrixBonesW)					* Input.Weights.w;
    }

    Params.VertexPosition   = position.xyz;
    Params.VertexNormal     = normal;

	Params.WorldPosition    = mul(float4(position.xyz, 1), g_ModelParams.MatrixWorld).xyz;
    Params.VertexColor      = Input.Color;

	if (IsParsyMesh)
		Params.ModelColor       = float4(1.0f, 1.0f, 1.0f, 1.0f);
	else
		Params.ModelColor       = ModelColor;

    Params.ParticleVertexColor = ModelColor;
    Params.ModelColorOffset = ModelColorOffset; 
    Params.VertexTangent    = float4(tangent, Input.Tangent.w);

#if NUM_USER_TEXCOORDS
    UNROLL for (int i = 0; i < NUM_USER_TEXCOORDS; i++)
        Params.TexCoords[i] = Input.TexCoords[i];
#endif

	float3 VertexOffset = position.xyz - Input.Position.xyz;
	if(length(VertexOffset) > 0.05f)
	{
		Params.WorldMotion 		= 0;
		Params.MotionPrecision 	= 0;
		Params.LastWorldPosition= mul(float4(position.xyz, 1), g_ModelParams.LastMatrixWorld);
		Params.LastWorldPosition.w = 1;
	}
	else
	{
		Params.WorldMotion 		= 0;
		Params.MotionPrecision 	= 1.f;
		Params.LastWorldPosition= mul(float4(position.xyz, 1), g_ModelParams.LastMatrixWorld);
		Params.LastWorldPosition.w = 1;
	}

	Params.MatrixWorld = g_ModelParams.MatrixWorld;
	Params.MatrixWorldInverse = g_ModelParams.MatrixWorldInverse;
	Params.MatrixWorldInverseTranspose = g_ModelParams.MatrixWorldInverseTranspose;

    return Params;
}

void GetMaterialVertexOutputs(MaterialVertexOutputs Output, out VertexOutput OutputImp)
{
    OutputImp.OutPosition           = Output.ScreenPosition;
    OutputImp.Color                 = Output.VertexColor;
    OutputImp.ParticleVertexColor   = Output.ParticleVertexColor;
    OutputImp.WorldPosition         = Output.WorldPosition;
    OutputImp.Normal_Fog.xyz        = Output.WorldNormal;
    OutputImp.Normal_Fog.w          = Output.FogFactor;
    OutputImp.ScreenPosition        = Output.ScreenPosition;
    OutputImp.VertexPosition        = Output.VertexPosition;
    OutputImp.VertexNormal          = Output.VertexNormal;

#if NUM_USER_TEXCOORDS
    UNROLL for (int i = 0; i < NUM_USER_TEXCOORDS; i++)
        OutputImp.TexCoords[i] = Output.TexCoords[i];
#endif

#ifdef NORMALMAP
    OutputImp.Tangent           = Output.VertexTangent.xyz;
	OutputImp.Binormal          = cross(Output.VertexNormal, Output.VertexTangent.xyz) * Output.VertexTangent.w;
#endif
	
	OutputImp.MatrixWorld0		= Output.MatrixWorld[0];
	OutputImp.MatrixWorld1		= Output.MatrixWorld[1];
	OutputImp.MatrixWorld2		= Output.MatrixWorld[2];
	OutputImp.MatrixWorld3		= Output.MatrixWorld[3];
	OutputImp.MatrixWorldInverse0 = Output.MatrixWorldInverse[0];
	OutputImp.MatrixWorldInverse1 = Output.MatrixWorldInverse[1];
	OutputImp.MatrixWorldInverse2 = Output.MatrixWorldInverse[2];
	OutputImp.MatrixWorldInverse3 = Output.MatrixWorldInverse[3];

    OutputImp.ClipDistance      = Output.ClipDistance;
	OutputImp.ScreenMotion		= float4( Output.ScreenMotion, Output.MotionPrecision, 1 );
#ifdef FUR
    OutputImp.Opacity           = 0.0f;
    OutputImp.FinOpacity        = float2(0.0f, 0.0f);
    OutputImp.Needed            = 1.0f;
#endif
}

MaterialPixelParameters GetMaterialParameters(VertexOutput Input)
{
    MaterialPixelParameters Params = (MaterialPixelParameters) 0;

#if NUM_USER_TEXCOORDS
    UNROLL for (int i = 0; i < NUM_USER_TEXCOORDS; i++)
        Params.TexCoords[i] = Input.TexCoords[i];
#endif

    Params.VertexColor      = Input.Color;
#ifdef PARSYS_MESH
	Params.ModelColor       = float4(1.0f, 1.0f, 1.0f, 1.0f);
#else
	Params.ModelColor       = ModelColor;
#endif
    Params.ModelColorOffset = ModelColorOffset;
    Params.ParticleVertexColor = Input.ParticleVertexColor;
    
    Params.WorldNormal      = normalize(Input.Normal_Fog.xyz);
    Params.FogFactor        = Input.Normal_Fog.w;
    Params.VertexPosition   = Input.VertexPosition.xyz;
    Params.VertexNormal     = normalize(Input.VertexNormal.xyz);
    Params.ScreenPosition   = Input.ScreenPosition;
	Params.OutPosition		= Input.OutPosition;
    Params.WorldPosition    = Input.WorldPosition.xyz;

#ifdef NORMALMAP
    Params.Tangent          = normalize(Input.Tangent);
    Params.Binormal         = normalize(Input.Binormal);
#endif
	
	Params.MatrixWorld[0]		= Input.MatrixWorld0;
	Params.MatrixWorld[1]		= Input.MatrixWorld1;
	Params.MatrixWorld[2]		= Input.MatrixWorld2;
	Params.MatrixWorld[3]		= Input.MatrixWorld3;
	Params.MatrixWorldInverse[0] = Input.MatrixWorldInverse0;
	Params.MatrixWorldInverse[1] = Input.MatrixWorldInverse1;
	Params.MatrixWorldInverse[2] = Input.MatrixWorldInverse2;
	Params.MatrixWorldInverse[3] = Input.MatrixWorldInverse3;
	Params.MatrixWorldInverseTranspose = transpose(Params.MatrixWorldInverse);

	Params.ScreenMotion		= Input.ScreenMotion.xy;
	Params.MotionPrecision	= Input.ScreenMotion.z;
	Params.IsMoving			= Input.ScreenMotion.w;
	
    return Params;
}


#define SKINMESH_SHADER
#define ENABLE_ZWRITING

//#include "ModelBaseVertexShader.fx5"

void VertexShaderMain(VertexInput Input, out VertexOutput OutputImp)
{
    MaterialVertexOutputs Output = (MaterialVertexOutputs)0;
	Output.MotionPrecision = 1.f;

    MaterialVertexParameters Params = GetMaterialVertexParameters(Input);

    ParamsMainVertexNode VertexMainNode = (ParamsMainVertexNode)0;
    CalculateMainVertexNode(Params, VertexMainNode);

    if(!any(Params.VertexNormal))
        Params.VertexNormal = float3(0, 1, 0);

    float4 Position         = float4(Params.VertexPosition + VertexMainNode.WorldPositionOffset, 1.0f);
    Output.WorldPosition    = mul(Position, Params.MatrixWorld);

#ifdef VERTEX_WORLDOFFSET
    Output.WorldPosition.xyz = Output.WorldPosition.xyz + Params.VertexWorldOffset;
#endif // VERTEX_WORLDOFFSET

    Output.ScreenPosition   = GetDeviceCoordinate(Output.WorldPosition, g_Com.Camera.CameraView, g_Com.Camera.CameraProject);
	//Output.ScreenPosition   = GetDeviceCoordinateWithSampleOffset(Output.WorldPosition, g_Com.Camera.CameraView, g_Com.Camera.CameraProject, g_Com.TaaSampleOffset);
    Output.VertexPosition   = Position;
    Output.VertexNormal     = Params.VertexNormal;

	Output.VertexColor      = Params.VertexColor;

    Output.ModelColor       = Params.ModelColor;
    Output.ModelColorOffset = Params.ModelColorOffset;
    Output.ParticleVertexColor = Params.ParticleVertexColor;

#ifdef USE_CUSTOM_LEAF_DISAPPEAR
	Output.fStartChangeTime  = Params.fStartChangeTime;
#endif // USE_CUSTOM_LEAF_DISAPPEAR

#if NUM_USER_TEXCOORDS
    UNROLL for (int i = 0; i < NUM_USER_TEXCOORDS; i++)
        Output.TexCoords[i] = Params.TexCoords[i];
#endif // NUM_USER_TEXCOORDS


	Output.FogFactor     = GetFogFactor(Output.ScreenPosition.z);
	Output.WorldNormal   = normalize(mul(Params.VertexNormal, (float3x3)Params.MatrixWorld));
#ifdef NORMALMAP
    Output.VertexTangent = Params.VertexTangent;
	//Output.WorldTangent  = normalize(mul(Params.VertexTangent.xyz, WorldMatrixForNormal));
	//Output.WorldBinormal = cross(Params.VertexNormal, Params.VertexTangent.xyz) * Params.VertexTangent.w;
	//Output.WorldBinormal = normalize(mul(Output.WorldBinormal, WorldMatrixForNormal));
#endif // NORMALMAP

    BRANCH if (g_Com.Switch.bEnableClip)
        Output.ClipDistance = dot(Output.WorldPosition, g_Com.ClipParam.ClipPlane);
    else
        Output.ClipDistance = 1.f;
	
	//world matrix
	Output.MatrixWorld = Params.MatrixWorld;
	Output.MatrixWorldInverse = Params.MatrixWorldInverse;	

    GetMaterialVertexOutputs(Output, OutputImp);
}

//#include "ModelBasePixelShader.fx5"


float4 PixelShaderMain(VertexOutput Input, uniform bool RenderSoftMask, PixelSystemInput SystemInput) : SV_Target0
{
    float4 OutColor = 0.0f;

    MaterialPixelParameters Params = GetMaterialParameters(Input);

    ParamsMainPixelNode PixelMainNode = (ParamsMainPixelNode)0;
	CalculateMainPixelNode(Params, PixelMainNode);

#ifdef SIMPLIFY_LIGHTING
    PixelMainNode.Normal = Params.VertexNormal;
#endif

	//Light Func
	float4 retColor = 0;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef LM_JX3
    float3 color = 0;
    color = PixelMainNode.Albedo;//PixelMainNode.Diffuse;

#ifdef SHADOWMAP
    float shadowMask = 1.0f;
    // if (shadowMapParam.bShadowMask)
     {
         //float2 screenpos = GetScreenpos(screenSpace.xy);
         //shadowMask = GetShadowMask(screenpos);
         shadowMask = GetShadowValue_SunLight_FromShadowMap_Classic(Params.WorldPosition) * g_Com.ShadowParam.ShadowDarkValue + (1 - g_Com.ShadowParam.ShadowDarkValue);
     }
#endif  

#ifdef SPECULAR
    float3 specularColor = PixelMainNode.SpecularColor;//PixelMainNode.Specular;
    float specularPower = 1;//PixelMainNode.Fresnel;//PixelMainNode.SpecularPower;
    if(specularPower<0.0001)
        specularPower = 15;
#endif

    float3 light = ComputeLight(
                    Params
#ifdef SPECULAR
                    ,specularColor,
                    specularPower,
                    0.5
#endif
#ifdef SSS
                    ,0.1
#endif
#ifdef SHADOWMAP
                    ,shadowMask
#endif
                    );   //use worldnormal inside
    color *= light;
    color +=  PixelMainNode.Ambient;
    color +=  PixelMainNode.Emissive;
    retColor.rgb = color;
    retColor.a = PixelMainNode.Opacity;
#endif    //light mode  


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	
 #ifdef LM_JX3_CLASSICPLAYER
    float3 color = 0;
    color = PixelMainNode.Albedo;//PixelMainNode.Diffuse;
#ifdef SHADOWMAP
    float shadowMask = 1.0f;
    // if (shadowMapParam.bShadowMask)
     {
        // float2 screenpos = GetScreenpos(screenSpace.xy);
        // shadowMask = GetShadowMaskForPlayer(screenpos);
        shadowMask = GetShadowValue_SunLight_FromShadowMap_Classic(Params.WorldPosition);
     }
#endif  
#ifdef SPECULAR
    float3 specularColor = PixelMainNode.SpecularColor;//PixelMainNode.Specular;
    float specularPower = 1;//PixelMainNode.Fresnel;//PixelMainNode.SpecularPower;
    if(specularPower<0.0001)
        specularPower = 15;
#endif
    float3 light = ComputeLight_JX3_ClassicPlayer(
                    Params,
					color
#ifdef SPECULAR
                    ,specularColor,
                    specularPower,
                    0.5
#endif
#ifdef SSS
                    ,0.1
#endif
#ifdef SHADOWMAP
                    ,shadowMask
#endif
                    );   //use worldnormal inside
    color *= light;
    color +=  PixelMainNode.Ambient;
    color +=  PixelMainNode.Emissive;
	
#ifdef COVERMAP
    if(g_Com.Switch.bEnableConvertMap)
	    color *= CalConverMap_Player(Params.WorldPosition);
#endif

    retColor.rgb = color;
    retColor.a = PixelMainNode.Opacity;
#endif    //light mode  


    OutColor.rgb = retColor.rgb;

    if (g_Com.Switch.bEnableFog)
    {
        OutColor = ApplyFog(OutColor, GetFogFactor(Input.ScreenPosition.z));
    }

    OutColor.a = PixelMainNode.Opacity * Params.ModelColor.a;
	
//#ifdef GAMMA_CORRECT_OUTPUT
//    OutColor = pow(OutColor, 0.4545f);
//#endif

	OutColor.a = saturate(OutColor.a);

    return OutColor;
}

VertexShader MainVertexShader = CompileShader(vs_5_0, VertexShaderMain());
PixelShader MainPixelShader = CompileShader(ps_5_0, PixelShaderMain(false));

technique11 Color
{
	pass p0
    {
        SetVertexShader(MainVertexShader); 
        SetPixelShader(MainPixelShader);
    }
}